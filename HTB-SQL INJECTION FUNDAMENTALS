# SQL Injection (SQLi)

# Some of the essential features of a DBMS include:

Feature	      Description
Concurrency	  A real-world application might have multiple users interacting with it simultaneously. A DBMS makes sure that these concurrent interactions succeed without corrupting or losing any data.
Consistency	  With so many concurrent interactions, the DBMS needs to ensure that the data remains consistent and valid throughout the database.
Security	    DBMS provides fine-grained security controls through user authentication and permissions. This will prevent unauthorized viewing or editing of sensitive data.
Reliability	  It is easy to backup databases and rolls them back to a previous state in case of data loss or a breach.
Structured    Query Language	SQL simplifies user interaction with the database with an intuitive syntax supporting various operations.

# Types of Databases

# Relational Databases

# A relational database is the most common type of database. It uses a schema, a template, to dictate the data structure stored in the database.
# For example, we can imagine a company that sells products to its customers having some form of stored knowledge about where those products go, to whom, and in what quantity.
# However, this is often done in the back-end and without obvious informing in the front-end. 

# Non-relational Databases

# A non-relational database (also called a NoSQL database) does not use tables, rows, and columns or prime keys, relationships, or schemas.
# Instead, a NoSQL database stores data using various storage models, depending on the type of data stored.
# Due to the lack of a defined structure for the database, NoSQL databases are very scalable and flexible.
# Therefore, when dealing with datasets that are not very well defined and structured, a NoSQL database would be the best choice for storing such data.

The above example can be represented using JSON as:

Code: json
{
  "100001": {
    "date": "01-01-2021",
    "content": "Welcome to this web application."
  },
  "100002": {
    "date": "02-01-2021",
    "content": "This is the first post on this web app."
  },
  "100003": {
    "date": "02-01-2021",
    "content": "Reminder: Tomorrow is the ..."
  }
}

# Intro to MySQL

# This module introduces SQL injection through MySQL, and it is crucial to learn more about MySQL and SQL to understand how SQL injections work and utilize them properly.
# Therefore, this section will cover some of MySQL/SQL's basics and syntax and examples used within MySQL/MariaDB databases.

# Connecting to MySQL

mysql -u root -h docker.hackthebox.eu -P 3306 -p 

# Creating a database

mysql> CREATE DATABASE users;

mysql> SHOW DATABASES;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| users              |
+--------------------+

mysql> USE users;

Database changed

# Tables

# DBMS stores data in the form of tables. A table is made up of horizontal rows and vertical columns.
# The intersection of a row and a column is called a cell. Every table is created with a fixed set of columns, where each column is of a particular data type.

Code: sql
CREATE TABLE logins (
    id INT,
    username VARCHAR(100),
    password VARCHAR(100),
    date_of_joining DATETIME
    );

mysql> SHOW TABLES;

+-----------------+
| Tables_in_users |
+-----------------+
| logins          |
+-----------------+

mysql> DESCRIBE logins;

+-----------------+--------------+
| Field           | Type         |
+-----------------+--------------+
| id              | int          |
| username        | varchar(100) |
| password        | varchar(100) |
| date_of_joining | date         |
+-----------------+--------------+
4 rows in set (0.00 sec)

# Table Properties

# Within the CREATE TABLE query, there are many properties that can be set for the table and each column.
# For example, we can set the id column to auto-increment using the AUTO_INCREMENT keyword, which automatically increments the id by one every time a new item is added to the table:

Code: sql
    id INT NOT NULL AUTO_INCREMENT,

Code: sql
    username VARCHAR(100) UNIQUE NOT NULL,

Code: sql
    date_of_joining DATETIME DEFAULT NOW(),

Code: sql
    PRIMARY KEY (id)

# The final CREATE TABLE query will be as follows:

Code: sql
CREATE TABLE logins (
    id INT NOT NULL AUTO_INCREMENT,
    username VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(100) NOT NULL,
    date_of_joining DATETIME DEFAULT NOW(),
    PRIMARY KEY (id)
    );

# SQL Statements

# INSERT Statement

INSERT INTO table_name VALUES (column1_value, column2_value, column3_value, ...);
INSERT INTO logins VALUES(1, 'admin', 'p@ssw0rd', '2020-07-02');

# The example above shows how to add a new login to the logins table, with appropriate values for each column.
# However, we can skip filling columns with default values, such as id and date_of_joining. This can be done by specifying the column names to insert values into a table selectively:

INSERT INTO table_name(column2, column3, ...) VALUES (column2_value, column3_value, ...);
INSERT INTO logins(username, password) VALUES('administrator', 'adm1n_p@ss');

# We inserted a username-password pair in the example above while skipping the id and date_of_joining columns.

# We can also insert multiple records at once by separating them with a comma:

INSERT INTO logins(username, password) VALUES ('john', 'john123!'), ('tom', 'tom123!');

# SELECT Statement

Code: sql
SELECT * FROM table_name;
SELECT * FROM logins;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+

Code: sql
SELECT column1, column2 FROM table_name;
SELECT username,password FROM logins;

+---------------+------------+
| username      | password   |
+---------------+------------+
| admin         | p@ssw0rd   |
| administrator | adm1n_p@ss |
| john          | john123!   |
| tom           | tom123!    |
+---------------+------------+

# DROP Statement
# The 'DROP' statement will permanently and completely delete the table with no confirmation, so it should be used with caution.

DROP TABLE logins;
SHOW TABLES;
Empty set (0.00 sec)

# ALTER Statement

ALTER TABLE logins ADD newColumn INT;

# To rename a column, we can use RENAME COLUMN:

ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn;

# We can also change a column's datatype with MODIFY:

ALTER TABLE logins MODIFY oldColumn DATE;

# We can drop a column using DROP:

ALTER TABLE logins DROP oldColumn;

# UPDATE Statement

Code: sql
UPDATE table_name SET column1=newvalue1, column2=newvalue2, ... WHERE <condition>;

UPDATE logins SET password = 'change_password' WHERE id > 1;

Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql> SELECT * FROM logins;

+----+---------------+-----------------+---------------------+
| id | username      | password        | date_of_joining     |
+----+---------------+-----------------+---------------------+
|  1 | admin         | p@ssw0rd        | 2020-07-02 00:00:00 |
|  2 | administrator | change_password | 2020-07-02 11:30:50 |
|  3 | john          | change_password | 2020-07-02 11:47:16 |
|  4 | tom           | change_password | 2020-07-02 11:47:16 |
+----+---------------+-----------------+---------------------+

# Query Results

# ORDER BY

SELECT * FROM logins ORDER BY password;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
4 rows in set (0.00 sec)

# By default, the sort is done in ascending order, but we can also sort the results by ASC or DESC:

SELECT * FROM logins ORDER BY password DESC;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
+----+---------------+------------+---------------------+
4 rows in set (0.00 sec)

# It is also possible to sort by multiple columns, to have a secondary sort for duplicate values in one column:

SELECT * FROM logins ORDER BY password DESC, id ASC;

+----+---------------+-----------------+---------------------+
| id | username      | password        | date_of_joining     |
+----+---------------+-----------------+---------------------+
|  1 | admin         | p@ssw0rd        | 2020-07-02 00:00:00 |
|  2 | administrator | change_password | 2020-07-02 11:30:50 |
|  3 | john          | change_password | 2020-07-02 11:47:16 |
|  4 | tom           | change_password | 2020-07-02 11:50:20 |
+----+---------------+-----------------+---------------------+
4 rows in set (0.00 sec)

# LIMIT results

mysql> SELECT * FROM logins LIMIT 2;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)

# If we wanted to LIMIT results with an offset, we could specify the offset before the LIMIT count:

mysql> SELECT * FROM logins LIMIT 1, 2;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)

# WHERE Clause

Code: sql
SELECT * FROM table_name WHERE <condition>;

mysql> SELECT * FROM logins WHERE id > 1;

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  2 | administrator | adm1n_p@ss | 2020-07-02 11:30:50 |
|  3 | john          | john123!   | 2020-07-02 11:47:16 |
|  4 | tom           | tom123!    | 2020-07-02 11:47:16 |
+----+---------------+------------+---------------------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM logins where username = 'admin';

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  1 | admin    | p@ssw0rd | 2020-07-02 00:00:00 |
+----+----------+----------+---------------------+
1 row in set (0.00 sec)

# LIKE Clause

mysql> SELECT * FROM logins WHERE username LIKE 'admin%';

+----+---------------+------------+---------------------+
| id | username      | password   | date_of_joining     |
+----+---------------+------------+---------------------+
|  1 | admin         | p@ssw0rd   | 2020-07-02 00:00:00 |
|  4 | administrator | adm1n_p@ss | 2020-07-02 15:19:02 |
+----+---------------+------------+---------------------+
2 rows in set (0.00 sec)

# The % symbol acts as a wildcard and matches all characters after admin. It is used to match zero or more characters.
# Similarly, the _ symbol is used to match exactly one character. The below query matches all usernames with exactly three characters in them, which in this case was tom:

mysql> SELECT * FROM logins WHERE username like '___';

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  3 | tom      | tom123!  | 2020-07-02 15:18:56 |
+----+----------+----------+---------------------+
1 row in set (0.01 sec)

SELECT FROM employees WHERE first_name LIKE 'Bar%';
